#! /bin/bash
##############################################################
##
## Name         :   munit
## Author       :   Bradley Atkins
## Description  :   Unit test harness for MUSE core functions
## Date         :   01/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##
##              :   MUNIT is released by Bradley Atkins 
##              :   Copyright (C) 2015 info@bradleyatkins.com
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, version 2 only.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  
## USA
##
##############################################################


##############################################################
##
## Name         :   cleanup
## Author       :   Bradley Atkins
## Description  :   Perform a clean exit in all states
## Date         :   01/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
cleanup()
{
    #======================================
    # Explicitely close any open descriptors
    # in case we are being called via ssh
    #======================================
    for fd in $(ls /proc/$$/fd); do
        case "$fd" in
            0|1|2|255)
            ;;
            *)
                eval "exec $fd>&-"
            ;;
        esac
    done
}


##############################################################
##
## Name         :   die
## Author       :   Bradley Atkins
## Description  :   Handle a fatal error
## Date         :   02/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
die()
{
    [[ -w "${MU_LOG}" ]] && echo "$(date): ERROR: ${1}" >> "${MU_LOG}"
    echo "$(date): ERROR: ${1}"
    exit 1
}

#======================================
# Bootstrap
#======================================
cd "$(dirname "$0")"
source ./ctl/user.env
source ./ctl/bootstrap
mu_validate_environment

#======================================
# Logging
#======================================
[[ -d $(dirname "${MU_LOG}") ]] || die "Log directory does not exist. ($(dirname ${MU_LOG})) Failed install? (munit)"
[[ -w $(dirname "${MU_LOG}") ]] || die "Log directory $(dirname ${MU_LOG})) is not writable. Failed install? (munit)"
if [[ -f "${MU_LOG}" ]] 
then
    [[ -w "${MU_LOG}" ]] || die "Log (${MU_LOG}) is not writable. Failed install? (munit)"
else
    :>"${MU_LOG}" || die "Log (${MU_LOG}) is not writable. Failed install? (munit)"
fi

#======================================
# Create a unique RUN ID
#======================================
MU_RUNID=$(date +"%Y%m%d%H%M%S")
mu_log_line "Starting test run - (${MU_RUNID})" "INFO"

#======================================
# Create the runtime directories
#======================================
mkdir -p "${MU_TMP}"
[[ -d "${MU_TMP}" ]] || die "Failed to create MUNIT TMP directory (${MU_TMP}) (munit)"
rm -rf "${MU_TMP}"/* || die "Cleardown of (${MU_TMP}) failed"
[[ -d "${MU_RPT}" ]] || die "Failed to create MUNIT report directory (${MU_RPT}) (munit)"
rm -rf "${MU_RPT}"/* || die "Cleardown of (${MU_RPT}) failed"

#======================================
# Initialise the run environment
#======================================
mu_init

#======================================
# Create the map files
#======================================
mu_create_map_files
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Map file created (${MU_MUNIT_MAP})" "INFO"

#======================================
# Validate the command line
#======================================
validate_cmd_line "$@"
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Command line validated ($@)" "INFO"

#======================================
# Parse the test suites and break out
# each test into its own exe
#======================================
mu_create_test_files
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Test files created" "INFO"

#======================================
# Set some run vars
#======================================
printf "%s\n" "Errors:" > "${MU_TEST_BUF}"
printf "%s\n" "Tests:" > "${MU_TEST_HED}"
mu_gen_line "=" "${MU_HEAD_LINE_LEN}" HEADLINE

include reporting.funcs
#======================================
# Run each test and create each report
#======================================
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Running Tests" "INFO"
MU_RUN_INDEX=0
while [[ $(( MU_RUN_INDEX += 1 )) -le ${MU_NUM_TESTS} ]]
do
    MU_TESTS=$(( MU_TESTS +1 ))
    THISTEST=${MU_RUN_ORDER[$MU_RUN_INDEX]}

    printf "\t%-4d - %s\n" "${MU_TESTS}" "${THISTEST}" >> "${MU_TEST_HED}"

    if ! "${MU_TMP}/${THISTEST}" 2> "${MU_ERROR_BUF}"
    then
        mu_set_error_index MU_ERROR_INDEX
        MU_ERRORS=$(( MU_ERRORS +1 ))
        printf "\n\t${MU_ERROR_INDEX} - %s\n" "${MU_RUN_ORDER[$MU_RUN_INDEX]}" >> "${MU_TEST_BUF}"
        while read LINE
        do
            printf "\t\t%s\n" "${LINE}" >> "${MU_TEST_BUF}"
        done < "${MU_ERROR_BUF}"
    fi
done

#=====================================
# Concat all of the reports into one
#======================================
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Compiling reports" "INFO"

#======================================
# Print the report header
#======================================
OFS=$(( MU_HEAD_LINE_LEN / 6 ))
printf "%s\n" "${HEADLINE}" > "${MU_TEST_LOG}"
printf "%-${OFS}s%s\n" "" "$(date): MUNIT Test Report" >> "${MU_TEST_LOG}"
printf "%-${OFS}s%s\n" "" "Project - (${MU_CURRENT_PROJECT})" >> "${MU_TEST_LOG}"
printf "%-${OFS}s%s\n" "" "(${MU_NUM_TESTS}) Tests, (_MU_ASSERTIONS_) Assertions, (_MU_FAILURES_) Failures. (_MU_ERRORS_) Errors" >> "${MU_TEST_LOG}"
printf "%s\n" "${HEADLINE}" >> "${MU_TEST_LOG}"

#======================================
# List of tests that were run
#======================================
if ${MU_DISPLAY_TEST_LIST}
then
    cat "${MU_TEST_HED}" >> "${MU_TEST_LOG}"
    echo >> "${MU_TEST_LOG}"
fi

#======================================
# Handle adding any failures to rpt
#======================================
MU_FAIL_INDEX=0
MU_RUN_INDEX=0

while [[ $(( MU_RUN_INDEX += 1 )) -le ${MU_NUM_TESTS} ]]
do
    #======================================
    # Report and stats files
    #======================================
    THISRPT="${MU_RPT}/${MU_RUN_ORDER[$MU_RUN_INDEX]}.rpt"
    THISSTS="${MU_RPT}/${MU_RUN_ORDER[$MU_RUN_INDEX]}.sts"
    [[ -r "${THISRPT}" ]] || die "Report (${THISRPT}) not found"
    [[ -r "${THISSTS}" ]] || die "Stats file (${THISSTS}) not found"
    #======================================
    # If report not empty then contains 
    # failures so read into master rpt
    #======================================
    if [[ -s "${THISRPT}" ]]
    then
        #======================================
        # If this is the first fail then print
        #======================================
        if ! "${MU_FAILURE_LINE_PRINTED}"
        then
            printf "%s\n" "Failures:" >> "${MU_TEST_LOG}"
            MU_FAILURE_LINE_PRINTED=true
        fi
        #======================================
        # Report name and lines from rpt
        #======================================
        printf "\n\t$(( MU_FAIL_INDEX += 1 )) - %s\n" "${MU_RUN_ORDER[$MU_RUN_INDEX]}" >> "${MU_TEST_LOG}"
        while read LINE
        do
            printf "\t\t%s\n" "${LINE}" >> "${MU_TEST_LOG}"
        done < "${THISRPT}"
    fi
    #======================================
    # Update the global metrics
    #======================================
    read assertions failures errors < "${THISSTS}"
    MU_ASSERTIONS=$(( MU_ASSERTIONS + assertions ))
    MU_FAILURES=$(( MU_FAILURES + failures ))
    MU_ERRORS=$(( MU_ERRORS + errors ))
done
printf "\n" >> "${MU_TEST_LOG}"

#======================================
# Update the header with the metrics
#======================================
sed -i '{
    s/_MU_ASSERTIONS_/'${MU_ASSERTIONS}'/
    s/_MU_FAILURES_/'${MU_FAILURES}'/
    s/_MU_ERRORS_/'${MU_ERRORS}'/
}' "${MU_TEST_LOG}"

#======================================
# Display the test report
#======================================
clear
[[ ${MU_ERRORS} -gt 0 ]] && grep -v -A1 '^[[:blank:]]*$' "${MU_TEST_BUF}" | grep -v '^--$' >> "${MU_TEST_LOG}"
grep -v -A1 '^[[:blank:]]*$' "${MU_TEST_LOG}" | grep -v '^--$'

if ${MU_DISPLAY_TEST_LIST} || [[ ${MU_ERRORS} -gt 0 ]] || [[ ${MU_FAILURES} -gt 0 ]]
then
    printf "%s\n" "${HEADLINE}"
fi
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Run complete for - (${MU_RUNID})" "INFO"


