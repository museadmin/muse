#! /bin/bash
##############################################################
##
## Name         :   munit
## Author       :   Bradley Atkins
## Description  :   Unit test harness for MUSE core functions
## Date         :   01/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##
##              :   MUNIT is released by Bradley Atkins 
##              :   Copyright (C) 2015 info@bradleyatkins.com
##
## This program is free software; you can redistribute it and/or modify
## it under the terms of the GNU General Public License as published by
## the Free Software Foundation, version 2 only.
##
## This program is distributed in the hope that it will be useful,
## but WITHOUT ANY WARRANTY; without even the implied warranty of
## MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
## GNU General Public License for more details.
##
## You should have received a copy of the GNU General Public License
## along with this program; if not, write to the Free Software
## Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  
## USA
##
##############################################################


##############################################################
##
## Name         :   cleanup
## Author       :   Bradley Atkins
## Description  :   Perform a clean exit in all states
## Date         :   01/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
cleanup()
{
    #======================================
    # Explicitely close any open descriptors
    # in case we are being called via ssh
    #======================================
    for fd in $(ls /proc/$$/fd); do
        case "$fd" in
            0|1|2|255)
            ;;
            *)
                eval "exec $fd>&-"
            ;;
        esac
    done
}


##############################################################
##
## Name         :   die
## Author       :   Bradley Atkins
## Description  :   Handle a fatal error
## Date         :   02/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
die()
{
    [[ -w "${MU_LOG}" ]] && echo "$(date): ERROR: ${1}" >> "${MU_LOG}"
    echo "$(date): ERROR: ${1}"
    exit 1
}

#======================================
# Bootstrap
#======================================
cd $(echo "$(cd "$(dirname "$0")"; pwd)")
source ./ctl/user.env
source ./ctl/munit.bootstrap
[[ -n "${MU_LOG}" ]] || die "Env variable MU_LOG not set (munit)"
[[ -n "${MU_MUNIT_ROOT}" ]] || die "Env variable MU_MUNIT_ROOT not set (munit)"
[[ -n "${MU_TMP}" ]] || die "Env variable MU_TMP not set (munit)"
[[ -d "${MU_TEST_DEFS}" ]] || die "Env variable MU_TEST_DEFS not a directory (munit)"
[[ -d "${MU_LIB}" ]] || die "Env variable MU_LIB not a directory (munit)"
[[ -d "${MU_CTL}" ]] || die "Env variable MU_CTL not a directory (munit)"
[[ -n "${MU_MUNIT_MAP}" ]] || die "Env variable MU_MUNIT_MAP not set (munit)"
[[ -n "${MU_TEST_LOG}" ]] || die "Env variable MU_TEST_LOG not set (munit)"
[[ -n "${MU_TEST_BUF}" ]] || die "Env variable MU_TEST_BUF not set (munit)"
[[ -n "${MU_ERROR_BUF}" ]] || die "Env variable MU_ERROR_BUF not set (munit)"

#======================================
# Logging
#======================================
[[ -d $(dirname "${MU_LOG}") ]] || die "Log directory does not exist. ($(dirname ${MU_LOG})) Failed install? (munit)"
[[ -w $(dirname "${MU_LOG}") ]] || die "Log directory $(dirname ${MU_LOG})) is not writable. Failed install? (munit)"
if [[ -f "${MU_LOG}" ]] 
then
    [[ -w "${MU_LOG}" ]] || die "Log (${MU_LOG}) is not writable. Failed install? (munit)"
else
    :>"${MU_LOG}" || die "Log (${MU_LOG}) is not writable. Failed install? (munit)"
fi

#======================================
# Create a unique RUN ID
#======================================
MU_RUNID=$(date +"%Y%m%d%H%M%S")
mu_log_line "Starting test run - (${MU_RUNID})" "INFO"

#======================================
# Create the runtime directories
#======================================
mkdir -p "${MU_TMP}"
[[ -d "${MU_TMP}" ]] || die "Failed to cretae MUNIT TMP directory (${MU_TMP}) (munit)"
rm -rf "${MU_TMP}"/* || die "Cleardown of (${MU_TMP}) failed"

#======================================
# Create the map files
#======================================
mu_create_map_files
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Map file created (${MU_MUNIT_MAP})" "INFO"

#======================================
# Validate the command line
#======================================
validate_cmd_line "$@"
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Command line validated ($@)" "INFO"

#=====================================
# Include the MUNIT libraries
#======================================
include assert-string.funcs
include assert-integer.funcs
include assert-float.funcs
include assert-file.funcs
include raise.funcs
include require.funcs
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Includes successfully sourced" "INFO"

#======================================
# Parse the test suites and break out
# each test into its own exe
#======================================
mu_create_test_files
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Test files created" "INFO"

#======================================
# Run each test and create each report
#======================================
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Running Tests" "INFO"
printf "%s\n" "Errors:" > "${MU_TEST_BUF}"
MU_ERROR_INDEX=0
mu_gen_line "=" "${MU_HEAD_LINE_LEN}" HEADLINE

MU_RUN_INDEX=0
while [[ $(( MU_RUN_INDEX += 1 )) -le ${MU_NUM_TESTS} ]]
do
    MU_TESTS=$(( MU_TESTS +1 ))
    THISTEST=${MU_RUN_ORDER[$MU_RUN_INDEX]}
    if ! source "${MU_TMP}/${THISTEST}" 2> "${MU_ERROR_BUF}"
    then
        MU_ERRORS=$(( MU_ERRORS +1 ))
        printf "\n\t$(( MU_ERROR_INDEX += 1 )) - %s\n" "${MU_RUN_ORDER[$MU_RUN_INDEX]}" >> "${MU_TEST_BUF}"
        while read LINE
        do
            printf "\t\t%s\n" "${LINE}" >> "${MU_TEST_BUF}"
        done < "${MU_ERROR_BUF}"
    fi
done

#======================================
# Concat all of the reports into one
#======================================
[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Compiling reports" "INFO"
printf "%s\n" "${HEADLINE}" > "${MU_TEST_LOG}"
printf "\t%s\n" "$(date): MUNIT Test Report" >> "${MU_TEST_LOG}"
printf "\t%s\n" "Project - (${MU_CURRENT_PROJECT})" >> "${MU_TEST_LOG}"
printf "\t%s\n" "(${MU_NUM_TESTS}) Tests, (${MU_ASSERTIONS}) Assertions, (${MU_FAILURES}) Failures. (${MU_ERRORS}) Errors" >> "${MU_TEST_LOG}"
printf "%s\n" "${HEADLINE}" >> "${MU_TEST_LOG}"
[[ ${MU_FAILURES} -gt 0 ]] && printf "%s\n" "Failures:" >> "${MU_TEST_LOG}"

MU_FAIL_INDEX=0
MU_RUN_INDEX=0
while [[ $(( MU_RUN_INDEX += 1 )) -le ${MU_NUM_TESTS} ]]
do
    THISRPT="${MU_TMP}/${MU_RUN_ORDER[$MU_RUN_INDEX]}.rpt"
    if [[ -s "${THISRPT}" ]]
    then
        printf "\n\t$(( MU_FAIL_INDEX += 1 )) - %s\n" "${MU_RUN_ORDER[$MU_RUN_INDEX]}" >> "${MU_TEST_LOG}"
        while read LINE
        do
            printf "\t\t%s\n" "${LINE}" >> "${MU_TEST_LOG}"
        done < "${THISRPT}"
    fi
done
printf "\n" >> "${MU_TEST_LOG}"


#======================================
# Display the test log
#======================================
[[ ${MU_ERRORS} -gt 0 ]] && grep -v -A1 '^[[:blank:]]*$' "${MU_TEST_BUF}" | grep -v '^--$' >> "${MU_TEST_LOG}"
grep -v -A1 '^[[:blank:]]*$' "${MU_TEST_LOG}" | grep -v '^--$'

printf "%s\n" "${HEADLINE}"

[[ "${MU_LOG_LEVEL}" == "DEBUG" ]] && mu_log_line "Run complete for - (${MU_RUNID})" "INFO"


