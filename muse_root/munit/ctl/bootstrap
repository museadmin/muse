#! /bin/bash
##############################################################
##
## Name         :   bootstrap
## Author       :   Bradley Atkins
## Description  :   Environment vars for MUNIT and common funcs
## Date         :   02/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################

set -a

    #======================================
    # MUNIT test definitions
    #======================================
    eval MU_MUNIT_ROOT="${MU_MAP_DIRS[1]}"

    #======================================
    # Path to MUNIT libraries
    #======================================
    MU_LIB="${MU_MUNIT_ROOT}/lib"
    MU_CTL="${MU_MUNIT_ROOT}/ctl"
    MU_TST="${MU_MUNIT_ROOT}/tst"

    #======================================
    # MUNIT control files
    #======================================
    MU_TMP="/var/tmp/munit/tmp"
    MU_RPT="/var/tmp/munit/rpt"
    MU_MUNIT_MAP="${MU_TMP}/mu_test_map"

    #======================================
    # Temporary runtime files
    #======================================
    MU_TEST_LOG="${MU_TMP}/mu_test_log"
    MU_TEST_BUF="${MU_TMP}/mu_test_buf"
    MU_TEST_HED="${MU_TMP}/mu_test_hed"
    MU_ERROR_BUF="${MU_TMP}/mu_error_buf"
    MU_ERROR_IDX="${MU_TMP}/mu_error_idx"   ## Index for error report

    #======================================
    # Global Constants
    #======================================
    MC_NAME_SEP="."
    MU_MENU_LINE_LEN=25
    MU_HEAD_LINE_LEN=75

    #======================================
    # Run Array for Test names
    #======================================
    declare -a MU_RUN_ORDER

##############################################################
##
## Name         :   mu_validate_environment
## Author       :   Bradley Atkins
## Description  :   Check we have sensible environment vars
## Date         :   07/08/2015
## Args         :   
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##                  Disabled    [n]
##############################################################
mu_validate_environment()
{
    [[ "${MU_MUNIT_ROOT}" =~ ^/.* ]] || die "MU_MUNIT_ROOT validation failed (${FUNCNAME})"
    [[ "${MU_LIB}" =~ ^/.*/lib ]] || die " MU_LIB validation failed (${FUNCNAME})"
    [[ "${MU_CTL}" =~ ^/.*/ctl ]] || die "MU_CTL validation failed (${FUNCNAME})"
    [[ "${MU_TST}" =~ ^/.*/tst ]] || die "MU_CTL validation failed (${FUNCNAME})"
    [[ "${MU_TMP}" =~ ^/.*/munit/tmp ]] || die "MU_TMP validation failed (${FUNCNAME})"
    [[ "${MU_MUNIT_MAP}" =~ ^/.*/mu_test_map ]] || die "MU_MUNIT_MAP validation failed (${FUNCNAME})"
    [[ "${MU_TEST_LOG}" =~ ^/.*/mu_test_log ]] || die "MU_TEST_LOG validation failed (${FUNCNAME})"
    [[ "${MU_TEST_BUF}" =~ ^/.*/mu_test_buf ]] || die "MU_TEST_BUF validation failed (${FUNCNAME})"
    [[ "${MU_TEST_HED}" =~ ^/.*/mu_test_hed ]] || die "MU_TEST_HED validation failed (${FUNCNAME})"
    [[ "${MU_ERROR_BUF}" =~ ^/.*/mu_error_buf ]] || die "MU_ERROR_BUF validation failed (${FUNCNAME})"
    [[ -n "${MC_NAME_SEP}" ]] || die "MC_NAME_SEP validation failed (${FUNCNAME})"
    [[ "${MU_MENU_LINE_LEN}" =~ ^[[:digit:]]+$ ]] || die "MU_MENU_LINE_LEN validation failed (${FUNCNAME})"
    [[ "${MU_HEAD_LINE_LEN}" =~ ^[[:digit:]]+$ ]] || die "MU_HEAD_LINE_LEN validation failed (${FUNCNAME})"
    MU_ERRORS=0
    MU_FAILURES=0
    MU_TESTS=0
    MU_ASSERTIONS=0
    MU_CMD_LINE=""
    MU_TEST_NAMES=""
    MU_CURRENT_PROJECT=""
    TMPFIL1=""
    TMPFILE2=""
    TMPFILE3=""
    TESTFILE=""
    #======================================
    # Reporting
    #======================================
    MU_FAILURE_LINE_PRINTED=false
    MU_ERROR_LINE_PRINTED=false
}
##############################################################
##
## Name         :   mu_init
## Author       :   Bradley Atkins
## Description  :   Setup the run environment
## Date         :   07/08/2015
## Args         :   
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##                  Disabled    [n]
##############################################################
mu_init()
{
    mkdir -p "${MU_TMP}" 2>/dev/null 
    mkdir -p "${MU_RPT}" 2>/dev/null
    [[ -d "${MU_TMP}" ]] || die "Failed to create tmp dir (${MU_TMP}) (${FUNCNAME})"
    [[ -d "${MU_RPT}" ]] || die "Failed to create tmp dir (${MU_RPT}) (${FUNCNAME})"
    printf "%s" "0" > "${MU_ERROR_IDX}"
}
##############################################################
##
## Name         :   usage
## Author       :   Bradley Atkins
## Description  :   Display the usage
## Date         :   01/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
usage()
{
    local HEADLINE= OFS=$(( MU_HEAD_LINE_LEN / 3 ))
    mu_gen_line "=" "${MU_HEAD_LINE_LEN}" HEADLINE

    printf "%s\n" "${HEADLINE}"
    printf "\n%-${OFS}s%s\n\n" "" "MUNIT Usage Guide"
    printf "\t%s\n" "usage: ${0##*/} [-option] [file] [file] ..."
    printf "\n"
    printf "\t%s\n" "${0##*/} <test name/s>  :Run test suite/s"
    printf "\t%s\n" "${0##*/} -s             :Select project and test/s"
    printf "\n%s\n" "${HEADLINE}"
    exit
}
##############################################################
##
## Name         :   mu_find_file
## Author       :   Bradley Atkins
## Description  :   Find a file. If no filter set then first 
##                  search MUNIT then MUSE. 
## Date         :   02/08/2015
## Args         :   1 - file name
##                  2 - Variable name for return value
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_find_file()
{
    [[ -n "${1}" ]] || die "Usage. Arg[1]. File name expected  (${FUNCNAME})"
    [[ -n "${2}" ]] || die "Usage. Arg[2]. Variable name expected  (${FUNCNAME})"
    local FPATH=
    [[ -r "${MU_MUNIT_MAP}" ]] || die "Failed to find readable MUNIT map file (${MU_MUNIT_MAP})  (${FUNCNAME})"

    while read FPATH
    do
        if [[ "$(basename ${FPATH})" == "${1}" ]] 
        then
            eval ${2}="${FPATH}"
            break
        fi
    done < "${MU_MUNIT_MAP}"
}
##############################################################
##
## Name         :   include
## Author       :   Bradley Atkins
## Description  :   Source file passed in arg 1
## Date         :   02/08/2015
## Args         :   1 - Library to include
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
include()
{
    [[ $# -eq 1 ]] || die "Usage. Arg[1]. Filename expected (${FUNCNAME})"
    local FILE=""

    #======================================
    # Find the file 
    #======================================
    mu_find_file "${1}" FILE 

    [[ -r "${FILE}" ]] || die "Include library (${FILE}) not a readable file (${FUNCNAME})"
    source "${FILE}" || die "Include failed for library (${FILE}) (${FUNCNAME})"
}
##############################################################
##
## Name         :   mu_get_tmp_file
## Author       :   Bradley Atkins
## Description  :   Create a tmp file
## Date         :   02/08/2015
## Args         :   1 - Calling function
##                  2 - Variable name to return path to file
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_get_tmp_file()
{
    [[ $# -eq 2 ]] || die "Usage. Arg count. 2 expected (${FUNCNAME})"
    [[ -n "${1}" ]] || die "Usage. Arg[1]. Caller name expected"
    [[ -n "${2}" ]] || die "Variable name expected"

    local FILE="${MU_TMP}/${1}.${RANDOM}"
    while [[ -f "${FILE}" ]] 
    do
        FILE="${MU_TMP}/${1}.${RANDOM}"
    done

    :>"${FILE}"

    eval ${2}='"${FILE}"'
}
##############################################################
##
## Name         :   mu_clean_file
## Author       :   Bradley Atkins
## Description  :   Strip out comments etc from a file
##                  If source and dest are the same then overwrite
## Date         :   02/08/2015
## Args         :   1 - Fully qualified file name (source)
##                  2 - Fully qualified file name (output)
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_clean_file()
{
    [[ $# -eq 2 ]] || die "Error: Usage args (${FUNCNAME})"

    local SRC="${1}" DST="${2}"

    #======================================
    # Name can be basename or FQN. If base 
    # then find it
    #======================================
    [[ -f "${1}" ]] || mu_find_file "${1}" SRC
    [[ -f "${2}" ]] || mu_find_file "${2}" DST

    #======================================
    # Clean the file of comments etc.
    #======================================
    if [[ "${SRC}" == "${DST}" ]] 
    then
        local FILE
        mu_get_tmp_file ${FUNCNAME} FILE 
        sed 's/[#].*$//g' "${SRC}" | awk NF > "${FILE}"
        for s in ${PIPESTATUS[@]}; do [[ $s -eq 0 ]] || die "Error:Pipe failed 1 (${FUNCNAME})" ; done 
        mv "${FILE}" > "${SRC}" || die "Failed to overwrite target file (${DST}) (${FUNCNAME})"
    else
        sed 's/[#].*$//g' "${SRC}" | awk NF > "${DST}" || die "Failed to overwrite target file (${DST}) (${FUNCNAME})"
        for s in ${PIPESTATUS[@]}; do [[ $s -eq 0 ]] || die "Error:Pipe failed 2 (${FUNCNAME})" ; done 
    fi
}
##############################################################
##
## Name         :   mu_gen_line
## Author       :   Bradley Atkins
## Description  :   Generate a line of character $1
## Date         :   06/08/2015
## Args         :   1 - Line type
##                  2 - Length of line
##                  3 - VAR to return line in
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##                  Disabled    [n]
##############################################################
mu_gen_line()
{
    [[ $# -eq 3 ]] || die "Usage. Arg count. 3 expected (${FUNCNAME})"
    [[ "${2}" =~ ^[[:digit:]]+$ ]] || die "Usage. Arg[2]. Integer expected (${FUNCNAME})"

    local L=
    for I in $(seq "${2}")
    do
        L="${L}${1}"
    done

    eval "${3}"='${L}'
}
##############################################################
##
## Name         :   validate_cmd_line
## Author       :   Bradley Atkins
## Description  :   Check the cmd line is valid
## Date         :   02/08/2015
## Args         :   1 - Entire command line
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
validate_cmd_line()
{
    [[ $# -eq 0 ]] && usage

    #======================================
    # Validate
    #======================================
    local FILE= OPT= PRJS= HLINE=
    mu_gen_line "=" "${MU_MENU_LINE_LEN}" HLINE

    while [[ $# -gt 0 ]]
    do
        case ${1} in
            mu_*)
                #======================================
                # User wants to run specific test/s
                #======================================
                [[ ${1} == mu_* ]] || die "Usage. Test name must begin with mu_"
                MU_TEST_NAMES="${MU_TEST_NAMES} ${1}"
                shift
            ;;
            -s)
                shift
                [[ $# -gt 0 ]] && usage

                ## Force a single column menu
                export COLUMNS=1

                #======================================
                # List all projects in a menu format.
                # Set current project from selection.
                #======================================
                if [[ -n $(ls -d tst/* 2>/dev/null | awk '{print $NF}' FS='/') ]]
                then
                    clear
                    echo "${HLINE}"
                    echo "Choose a project"
                    echo "${HLINE}"

                    PS3='Set working project: '
                    OPTIONS=($(ls -d tst/* 2>/dev/null | awk '{print $NF}' FS='/') "Quit")
                    select OPT in "${OPTIONS[@]}"
                    do
                        ## Choice out of range
                        [[ "${REPLY}" -gt "${#OPTIONS[@]}" ]] && continue
                        
                        case "${OPT}" in
                            "Quit")
                                exit
                                ;;
                            *)
                                
                                #======================================
                                # Need another menu of tests within 
                                # the project
                                #======================================
                                MU_CURRENT_PROJECT="${OPT}"
                                clear
                                TESTS="$(ls -f tst/"${MU_CURRENT_PROJECT}"/mu_test* 2>/dev/null | awk '{print $NF}' FS='/')"
                                if [[ -n "${TESTS}" ]] 
                                then
                                    echo "${HLINE}"
                                    echo "Choose a test"
                                    echo "${HLINE}"
                                    
                                    PS3='Select test to run: '
                                    OPTIONS=("All" ${TESTS} "Quit")
                                    
                                    select OPT in "${OPTIONS[@]}"
                                    do
                                        ## Choice out of range
                                        [[ "${REPLY}" -gt "${#OPTIONS[@]}" ]] && continue
                                        
                                        case "${OPT}" in 
                                            "All") 
                                                #======================================
                                                # User wants to run all tests
                                                #======================================
                                                for FILE in ${TESTS}
                                                do
                                                    MU_TEST_NAMES="${MU_TEST_NAMES} $(basename ${FILE})"
                                                done
                                                break
                                            ;;
                                            "Quit")
                                                exit
                                            ;;
                                            *)
                                                MU_TEST_NAMES="${OPT}"
                                                break
                                            ;;
                                        esac
                                    done
                                    clear
                                    break
                                else
                                    echo "${HLINE}"
                                    echo "No test files found in project (${MU_CURRENT_PROJECT})"
                                    echo "${HLINE}"
                                    exit
                                fi
                                ;;
                        esac
                    done
                    else
                    echo "${HLINE}"
                    echo "No projects found in test directory"
                    echo "${HLINE}"
                    exit
                fi
            ;;
        esac
    done
    
    #======================================
    # Confirm they can all be found
    #======================================
    for FILE in ${MU_TEST_NAMES}
    do
        mu_find_file "${FILE}" FILE
    done
}
##############################################################
##
## Name         :   mu_log_line
## Author       :   Bradley Atkins
## Description  :   Write a line to the log
## Date         :   02/08/2015
## Args         :   1 - Line
##                  2 - Error Level
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_log_line()
{
    [[ "${1}" == "Failed to write to log" ]] && return

    echo "$(date): ${2}: ${1}" >> "${MU_LOG}" || die "Failed to write to log"
}
##############################################################
##
## Name         :   mu_create_map_files
## Author       :   Bradley Atkins
## Description  :   Create the map files for MUSE and MUNIT
## Date         :   02/08/2015
## Args         :   
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_create_map_files()
{
    local DIR
    for DIR in ${MU_MAP_DIRS[@]}
    do
        find ${DIR} -type f >> "${MU_MUNIT_MAP}" 2>/dev/null || die "Find failed for (${DIR}) (munit)"
    done
}
##############################################################
##
## Name         :   mu_check_test_suite_format
## Author       :   Bradley Atkins
## Description  :   Basic sanity checks on file format
## Date         :   02/08/2015
## Args         :   1 - Test file
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_check_test_suite_format()
{
    [[ -r "${1}" ]] || die "Usage. Arg[1]. Test file expected (${FUNCNAME})"

    local LINE= EXP="def"
    #======================================
    # Correct sequence of def - end pairs?
    #======================================
    [[ $(egrep "^def" "${1}" | wc -l) -eq $(egrep "^end" "${1}" | wc -l) ]] || die "Unequal number of \"def\" \"end\" pairs in (${1}) (${FUNCNAME})"
    for LINE in $(egrep "^def|^end" "${1}" | cut -d" " -f1)
    do
        [[ "${LINE}" == "${EXP}" ]] || die "Sequence of \"def\" \"end\" pairs failed (${FUNCNAME})"
        if [[ "${EXP}" == "def" ]]
        then
            EXP="end"
        else
            EXP="def"
        fi
    done

    [[ "${EXP}" == "def" ]] || die "Test unterminated by def statement"
}
##############################################################
##
## Name         :   mu_create_test_files
## Author       :   Bradley Atkins
## Description  :   Parse the test suites and break them out 
##                  into individual executables
## Date         :   03/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_create_test_files()
{
    local TEST_SUITE= TMPFILE1= TMPFILE2= LINE= RCNT= UCNT=
    #======================================
    # Loop through all test suites
    #======================================
    for TEST_SUITE in ${MU_TEST_NAMES}
    do
        mu_find_file "${TEST_SUITE}" TMPFILE1

        #======================================
        # Prepare and sanity check test file
        #======================================
        mu_get_tmp_file "${FUNCNAME}" TESTSUITE
        mu_clean_file "${TMPFILE1}" "${TESTSUITE}"
        mu_check_test_suite_format "${TESTSUITE}"

        #======================================
        # Loop through all tests within suite
        # and create a bash script for each one
        # SUITE_NAME.TEST_NAME.tst in MU_TMP
        # Add name to run array
        # Copy test lines into file with #!
        # Move this into a function and call it
        #======================================
        while read LINE
        do
            if [[ "${LINE}" =~ ^"TEST=" ]] 
            then
                #======================================
                # Record the testname in the run array
                #======================================
                TEST_NAME=${MU_CURRENT_PROJECT}${MC_NAME_SEP}${TEST_SUITE}${MC_NAME_SEP}$(echo "${LINE}" | cut -d"=" -f2)
                MU_RUN_ORDER[$(( MU_RUN_INDEX += 1 ))]="${TEST_NAME}"
                TEST_FILE="${MU_TMP}/${TEST_NAME}"
                printf "%s\n" "#! /bin/bash" > "${TEST_FILE}"
                [[ "${MU_DEBUG_TEST}" == "TRUE" ]] && printf "%s\n" "set -x" >> "${TEST_FILE}"
                printf "%s\n" "export THIS_TEST_NAME=${TEST_NAME}" >> "${TEST_FILE}"
                printf "%s\n" "export MU_TMP=${MU_TMP}" >> "${TEST_FILE}"
                printf "%s\n" "export MU_RPT=${MU_RPT}" >> "${TEST_FILE}"
                printf "%s\n" "export MU_ERROR_IDX=${MU_ERROR_IDX}" >> "${TEST_FILE}"
                printf "%s\n" "export MU_TEST_BUF=${MU_TEST_BUF}" >> "${TEST_FILE}"
                #======================================
                # Add source of all libraries
                #======================================
                for f in $(ls "${MU_LIB}/"*.funcs)
                do
                    printf "%s\n" "source ${f}" >> "${TEST_FILE}"
                done

                chmod +x "${TEST_FILE}"
                MU_NUM_TESTS=$(( MU_NUM_TESTS + 1 ))
                
                #======================================
                # Create a stats file for it
                #======================================
                printf "%s" "0 0 0" > "${MU_RPT}/${TEST_NAME}.sts"
                :>"${MU_RPT}/${TEST_NAME}.rpt"
            else
                printf "%s\n" "$LINE" | sed '{
                    s/\(require .*\)/\1 || exit 1/
                    s/\(import .*\)/\1 || exit 1/
                }' >> "${TEST_FILE}"
            fi
        done < <( awk '/^def/{printf "%s%s\n", "TEST=", $2;next}
                        !/^end/{printf "%s\n", $0}
                            ' FS=" " "${TESTSUITE}")
    done

    #======================================
    # Check for duplicate test names
    #======================================
    mu_get_tmp_file "${FUNCNAME}2" TMPFILE2
    for TEST_NAME in ${MU_RUN_ORDER[@]}
    do
        echo "${TEST_NAME}" >> "${TMPFILE2}"
    done
    
    if ! diff <(sort "${TMPFILE2}") <(sort -u "${TMPFILE2}") > /dev/null 2>&1
    then
        echo "==========================================================="
        echo "Duplicate names in test files"
        echo "==========================================================="
        diff <(sort "${TMPFILE2}") <(sort -u "${TMPFILE2}") | sed 's/< //g' | egrep mu_
        echo "==========================================================="
    fi
}
##############################################################
##
## Name         :   mu_log_failure
## Author       :   Bradley Atkins
## Description  :   Write a failure to the report
## Date         :   03/08/2015
## Args         :   1 - MSG
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_log_failure()
{
    #======================================
    # Print the failures header line
    #======================================
    if ! ${MU_FAILURE_LINE_PRINTED}
    then
        printf "%s\n" "Failures:" > "${MU_TEST_LOG}"
    fi

    #======================================
    # Print the failure details
    #======================================
    printf "%s\n" "(${MU_FAILURES})" >> "${MU_TEST_LOG}"
}

set +a
