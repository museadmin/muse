#! /bin/bash
##############################################################
##
## Name         :   munit.bootstrap
## Author       :   Bradley Atkins
## Description  :   Environment vars for MUNIT
## Date         :   02/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################

set -a

    #======================================
    # MUNIT test definitions
    #======================================
    eval MU_MUNIT_ROOT="${MU_MAP_DIRS[1]}"
    MU_TEST_DEFS="${MU_MUNIT_ROOT}/test"

    #======================================
    # Path to MUNIT libraries
    #======================================
    MU_LIB="${MU_MUNIT_ROOT}/lib"

    #======================================
    # MUNIT control files
    #======================================
    MU_CTL="${MU_MUNIT_ROOT}/ctl"
    MU_TMP="/var/tmp/munit/tmp"
    MU_MUNIT_MAP="${MU_TMP}/mu_test_map"

    #======================================
    # Temporary runtime files
    #======================================
    MU_TEST_LOG="${MU_TMP}/mu_test_log"
    MU_TEST_BUF="${MU_TMP}/mu_test_buf"
    MU_ERROR_BUF="${MU_TMP}/mu_error_buf"

    #======================================
    # Global Constants
    #======================================
    MC_NAME_SEP="."

    #======================================
    # Runtime vars
    #======================================
    MU_ERRORS=0
    MU_FAILURES=0
    MU_TESTS=0
    MU_ASSERTIONS=0
    MU_CMD_LINE=""
    MU_TEST_NAMES=""

    TMPFIL1=""
    TMPFILE2=""
    TMPFILE3=""

    TESTFILE=""

    #======================================
    # Run Array for Test names
    #======================================
    declare -a MU_RUN_ORDER
    MU_RUN_INDEX=0
    MU_NUM_TESTS=0
    MU_ERROR_INDEX=0
    MU_FAIL_INDEX=0

    #======================================
    # Reporting
    #======================================
    MU_FAILURE_LINE_PRINTED=false


##############################################################
##
## Name         :   usage
## Author       :   Bradley Atkins
## Description  :   Display the usage
## Date         :   01/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
usage()
{
    printf "\n"
    printf "\t%s\n" "usage: ${0##*/} [-option] file file ..."
    printf "\n"
    printf "\t%s\n" "${0##*/} <test name/s>         :Run a test suite"
    printf "\t%s\n" "${0##*/} -a                    :Run all tests in current project"
    printf "\t%s\n" "${0##*/} -s                    :Select current project and tests"
    exit
}
##############################################################
##
## Name         :   mu_find_file
## Author       :   Bradley Atkins
## Description  :   Find a file. If no filter set then first 
##                  search MUNIT then MUSE. 
## Date         :   02/08/2015
## Args         :   1 - file name
##                  2 - Variable name for return value
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_find_file()
{
    [[ -n "${1}" ]] || die "Usage. Arg[1]. File name expected  (${FUNCNAME})"
    [[ -n "${2}" ]] || die "Usage. Arg[2]. Variable name expected  (${FUNCNAME})"
    local FPATH=
    [[ -r "${MU_MUNIT_MAP}" ]] || die "Failed to find readable MUNIT map file (${MU_MUNIT_MAP})  (${FUNCNAME})"

    while read FPATH
    do
        if [[ "$(basename ${FPATH})" == "${1}" ]] 
        then
            eval ${2}="${FPATH}"
            break
        fi
    done < "${MU_MUNIT_MAP}"
}
##############################################################
##
## Name         :   include
## Author       :   Bradley Atkins
## Description  :   Source file passed in arg 1
## Date         :   02/08/2015
## Args         :   1 - Library to include
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
include()
{
    [[ $# -eq 1 ]] || die "Usage. Arg[1]. Filename expected (${FUNCNAME})"
    local FILE=""

    #======================================
    # Find the file 
    #======================================
    mu_find_file "${1}" FILE 

    [[ -r "${FILE}" ]] || die "Include library (${FILE}) not a readable file (${FUNCNAME})"
    source "${FILE}" || die "Include failed for library (${FILE}) (${FUNCNAME})"
}
##############################################################
##
## Name         :   mu_get_tmp_file
## Author       :   Bradley Atkins
## Description  :   Create a tmp file
## Date         :   02/08/2015
## Args         :   1 - Calling function
##                  2 - Variable name to return path to file
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_get_tmp_file()
{
    [[ $# -eq 2 ]] || die "Usage. Arg count. 2 expected (${FUNCNAME})"
    [[ -n "${1}" ]] || die "Usage. Arg[1]. Caller name expected"
    [[ -n "${2}" ]] || die "Variable name expected"

    local FILE="${MU_TMP}/${1}.${RANDOM}"
    while [[ -f "${FILE}" ]] 
    do
        FILE="${MU_TMP}/${1}.${RANDOM}"
    done

    :>"${FILE}"

    eval ${2}='"${FILE}"'
}
##############################################################
##
## Name         :   mu_clean_file
## Author       :   Bradley Atkins
## Description  :   Strip out comments etc from a file
##                  If source and dest are the same then overwrite
## Date         :   02/08/2015
## Args         :   1 - Fully qualified file name (source)
##                  2 - Fully qualified file name (output)
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_clean_file()
{
    [[ $# -eq 2 ]] || die "Error: Usage args (${FUNCNAME})"

    local SRC="${1}" DST="${2}"

    #======================================
    # Name can be basename or FQN. If base 
    # then find it
    #======================================
    [[ -f "${1}" ]] || mu_find_file "${1}" SRC
    [[ -f "${2}" ]] || mu_find_file "${2}" DST

    #======================================
    # Clean the file of comments etc.
    #======================================
    if [[ "${SRC}" == "${DST}" ]] 
    then
        local FILE
        mu_get_tmp_file ${FUNCNAME} FILE 
        sed 's/[#].*$//g' "${SRC}" | awk NF > "${FILE}"
        for s in ${PIPESTATUS[@]}; do [[ $s -eq 0 ]] || die "Error:Pipe failed 1 (${FUNCNAME})" ; done 
        mv "${FILE}" > "${SRC}" || die "Failed to overwrite target file (${DST}) (${FUNCNAME})"
    else
        sed 's/[#].*$//g' "${SRC}" | awk NF > "${DST}" || die "Failed to overwrite target file (${DST}) (${FUNCNAME})"
        for s in ${PIPESTATUS[@]}; do [[ $s -eq 0 ]] || die "Error:Pipe failed 2 (${FUNCNAME})" ; done 
    fi
}
##############################################################
##
## Name         :   validate_cmd_line
## Author       :   Bradley Atkins
## Description  :   Check the cmd line is valid
## Date         :   02/08/2015
## Args         :   1 - Entire command line
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
validate_cmd_line()
{
    local FILE= PRJS=

    while [[ $# -gt 0 ]]
    do
        case ${1} in
            -a|--all)
                
                shift
                [[ $# -gt 0 ]] && die "Usage. Option (${1}) requires no arguments"

                #======================================
                # User wants to run all tests
                #======================================
                for FILE in $(find "${MU_TEST_DEFS}" -type f -name mu_\*)
                do
                    MU_TEST_NAMES="${MU_TEST_NAMES} $(basename ${FILE})"
                done
                [[ -n "${MU_TEST_NAMES}" ]] || die "No tests found in (${MU_TEST_DEFS})"
            ;;
            mu_*)
                #======================================
                # User wants to run specific test/s
                #======================================
                [[ ${1} == mu_* ]] || die "Usage. Test name must begin with mu_"
                MU_TEST_NAMES="${MU_TEST_NAMES} ${1}"
                shift
            ;;
            -s)
                shift
                [[ $# -gt 0 ]] && usage

                ## Force a single column menu
                export COLUMNS=1

                #======================================
                # List all projects in a menu format.
                # Set current project from selection.
                #======================================
                if [[ -n $(ls -d test/* 2>/dev/null | awk '{print $NF}' FS='/') ]]
                then
                    clear
                    PS3='Set working project:'
                    OPTIONS=($(ls -d test/* 2>/dev/null | awk '{print $NF}' FS='/') "Quit")
                    select OPT in "${OPTIONS[@]}"
                    do
                        ## Choice out of range
                        [[ "${REPLY}" -gt "${#OPTIONS[@]}" ]] && continue
                        
                        case "${OPT}" in
                            "Quit")
                                exit
                                ;;
                            *)
                                #======================================
                                # Need another menu of tests within 
                                # the project
                                #======================================
                                PRJ="${OPT}"
                                clear
                                TESTS="$(ls -f test/"${PRJ}"/mu_test* 2>/dev/null | awk '{print $NF}' FS='/')"
                                if [[ -n "${TESTS}" ]] 
                                then
                                    PS3='Select test to run:'
                                    OPTIONS=("All" ${TESTS} "Quit")
                                    select OPT in "${OPTIONS[@]}"
                                    do
                                        ## Choice out of range
                                        [[ "${REPLY}" -gt "${#OPTIONS[@]}" ]] && continue
                                        
                                        case "${OPT}" in 
                                            "All") 
                                                #======================================
                                                # User wants to run all tests
                                                #======================================
                                                for FILE in ${TESTS}
                                                do
                                                    MU_TEST_NAMES="${MU_TEST_NAMES} $(basename ${FILE})"
                                                done
                                                break
                                            ;;
                                            "Quit")
                                                exit
                                            ;;
                                            *)
                                                MU_TEST_NAMES="${OPT}"
                                                break
                                            ;;
                                        esac
                                    done
                                    break
                                else
                                    echo "No test files found in project (${PRJ})"
                                    exit
                                fi
                                ;;
                        esac
                    done
                    else
                    echo "No projects found in test directory"
                    exit
                fi
            ;;
            -t)
                #======================================
                # List all tests sorted by project then
                # name in menu form. Run selection.
                #======================================
                echo "TODO"
            ;;
        esac
    done
    
    #======================================
    # Confirm they can all be found
    #======================================
    for FILE in ${MU_TEST_NAMES}
    do
        mu_find_file "${FILE}" FILE
    done
}
##############################################################
##
## Name         :   mu_log_line
## Author       :   Bradley Atkins
## Description  :   Write a line to the log
## Date         :   02/08/2015
## Args         :   1 - Line
##                  2 - Error Level
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_log_line()
{
    [[ "${1}" == "Failed to write to log" ]] && return

    echo "$(date): ${2}: ${1}" >> "${MU_LOG}" || die "Failed to write to log"
}
##############################################################
##
## Name         :   mu_create_map_files
## Author       :   Bradley Atkins
## Description  :   Create the map files for MUSE and MUNIT
## Date         :   02/08/2015
## Args         :   
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_create_map_files()
{
    local DIR
    for DIR in ${MU_MAP_DIRS[@]}
    do
        find ${DIR} -type f >> "${MU_MUNIT_MAP}" 2>/dev/null || die "Find failed for (${DIR}) (munit)"
    done
}
##############################################################
##
## Name         :   mu_check_test_suite_format
## Author       :   Bradley Atkins
## Description  :   Basic sanity checks on file format
## Date         :   02/08/2015
## Args         :   1 - Test file
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_check_test_suite_format()
{
    [[ -r "${1}" ]] || die "Usage. Arg[1]. Test file expected (${FUNCNAME})"

    local LINE= EXP="def"
    #======================================
    # Correct sequence of def - end pairs?
    #======================================
    [[ $(egrep "^def" "${1}" | wc -l) -eq $(egrep "^end" "${1}" | wc -l) ]] || die "Unequal number of \"def\" \"end\" pairs in (${1}) (${FUNCNAME})"
    for LINE in $(egrep "^def|^end" "${1}" | cut -d" " -f1)
    do
        [[ "${LINE}" == "${EXP}" ]] || die "Sequence of \"def\" \"end\" pairs failed (${FUNCNAME})"
        if [[ "${EXP}" == "def" ]]
        then
            EXP="end"
        else
            EXP="def"
        fi
    done

    [[ "${EXP}" == "def" ]] || die "Test unterminated by def statement"
}
##############################################################
##
## Name         :   mu_create_test_files
## Author       :   Bradley Atkins
## Description  :   Parse the test suites and break them out 
##                  into individual executables
## Date         :   03/08/2015
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_create_test_files()
{
    local TEST_SUITE= TMPFILE1= TMPFILE2= LINE= RCNT= UCNT=
    #======================================
    # Loop through all test suites
    #======================================
    for TEST_SUITE in ${MU_TEST_NAMES}
    do
        mu_find_file "${TEST_SUITE}" TMPFILE1

        #======================================
        # Prepare and sanity check test file
        #======================================
        mu_get_tmp_file "${FUNCNAME}" TESTSUITE
        mu_clean_file "${TMPFILE1}" "${TESTSUITE}"
        mu_check_test_suite_format "${TESTSUITE}"

        #======================================
        # Loop through all tests within suite
        # and create a bash script for each one
        # SUITE_NAME.TEST_NAME.tst in MU_TMP
        # Add name to run array
        # Copy test lines into file with #!
        # Move this into a function and call it
        #======================================
        while read LINE
        do
            if [[ "${LINE}" =~ ^"TEST=" ]] 
            then
                #======================================
                # Record the testname in the run array
                # TODO refactor for project name
                #======================================
                TEST_NAME=${TEST_SUITE}${MC_NAME_SEP}$(echo "${LINE}" | cut -d"=" -f2)
                MU_RUN_ORDER[$(( MU_RUN_INDEX += 1 ))]="${TEST_NAME}"
                TEST_FILE="${MU_TMP}/${TEST_NAME}"
                printf "%s\n" "#! /bin/bash" > "${TEST_FILE}"
                printf "%s\n" "export THIS_TEST_NAME=${TEST_NAME}" >> "${TEST_FILE}"
                chmod +x "${TEST_FILE}"
                MU_NUM_TESTS=$(( MU_NUM_TESTS + 1 ))
            else
                printf "%s\n" "$LINE" | sed '{
                    s/\(require .*\)/\1 || return 0/
                    s/\(import .*\)/\1 || return 0/
                }' >> "${TEST_FILE}"
            fi
        done < <( awk '/^def/{printf "%s%s\n", "TEST=", $2;next}
                        !/^end/{printf "%s\n", $0}
                            ' FS=" " "${TESTSUITE}")
    done

    #======================================
    # Check for duplicate test names
    #======================================
    mu_get_tmp_file "${FUNCNAME}2" TMPFILE2
    for TEST_NAME in ${MU_RUN_ORDER[@]}
    do
        echo "${TEST_NAME}" >> "${TMPFILE2}"
    done
    
    if ! diff <(sort "${TMPFILE2}") <(sort -u "${TMPFILE2}") > /dev/null 2>&1
    then
        echo "==========================================================="
        echo "Duplicate names in test files"
        echo "==========================================================="
        diff <(sort "${TMPFILE2}") <(sort -u "${TMPFILE2}") | sed 's/< //g' | egrep mu_
        echo "==========================================================="
    fi
}
##############################################################
##
## Name         :   mu_log_failure
## Author       :   Bradley Atkins
## Description  :   Write a failure to the report
## Date         :   03/08/2015
## Args         :   1 - MSG
## Status       :   Reviewed    [n]
##                  Tested      [n]
##                  Released    [n]
##############################################################
mu_log_failure()
{
    #======================================
    # Print the failures header line
    #======================================
    if ! ${MU_FAILURE_LINE_PRINTED}
    then
        printf "%s\n" "Failures:" > "${MU_TEST_LOG}"
    fi

    #======================================
    # Print the failure details
    #======================================
    printf "%s\n" "(${MU_FAILURES})" >> "${MU_TEST_LOG}"
}

set +a
